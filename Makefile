IMAGE = bin/PatchworkOS.img

VERSION_HEADER = include/kernel/version.h
VERSION_STRING := $(shell git describe --tags --always --dirty --long 2>/dev/null || echo "unknown")

SECTIONS = boot kernel libstd libpatchwork
PACKAGES = $(shell find src/pkg/ -name "*.mk")
PROGRAMS = $(shell find src/programs/ -name "*.mk")
MODULES = $(shell find src/modules/ -name "*.mk")

ROOT_DIRS = acpi sys sys/bin sys/lib sys/include sys/data pkg cfg dev efi efi/boot kernel kernel/modules kernel/modules/$(VERSION_STRING) net proc sbin usr

# Programs to copy to /bin
#BIN_PROGRAMS = shell cat echo grep link ls mv readlink rm root stat symlink tail touch wall cursor taskbar dwm

# Programs to copy to /sbin
SBIN_PROGRAMS = init pkgd
# Programs to copy to /sys/bin
SYS_BIN_PROGRAMS = launch shell cat echo grep link ls mv readlink rm root stat symlink tail touch

# Programs to copy to /usr/bin
#USR_BIN_PROGRAMS = $(filter-out $(BIN_PROGRAMS) $(SBIN_PROGRAMS),$(basename $(notdir $(shell find bin/programs/))))

PKG_PACKAGES = $(basename $(notdir $(shell find bin/pkg/)))

.PHONY: $(SECTIONS) $(PROGRAMS) $(PACKAGES) argon2 $(MODULES) all setup deploy run clean generate_version compile_commands format doxygen clean clean_programs nuke grub_loopback clone_acpica_and_compile_tests

all: setup $(SECTIONS) $(MODULES) $(PACKAGES) $(PROGRAMS) deploy

generate_version:
	@printf "#pragma once\n\n" > $(VERSION_HEADER).tmp
	@printf "/**\n" >> $(VERSION_HEADER).tmp
	@printf " * @file version.h\n" >> $(VERSION_HEADER).tmp
	@printf " * @brief Generated by Makefile from Git information.\n" >> $(VERSION_HEADER).tmp
	@printf " */\n\n" >> $(VERSION_HEADER).tmp
	@printf "#define OS_NAME \"PatchworkOS\"\n" >> $(VERSION_HEADER).tmp
	@printf "#define OS_VERSION \"$(VERSION_STRING)\"\n\n" >> $(VERSION_HEADER).tmp
	@if ! cmp -s $(VERSION_HEADER) $(VERSION_HEADER).tmp; then \
		mv $(VERSION_HEADER).tmp $(VERSION_HEADER); \
	else \
		rm $(VERSION_HEADER).tmp; \
	fi

ifeq ($(TESTING),1)
setup: generate_version clone_acpica_and_compile_tests
	$(MAKE) -C lib/gnu-efi
else
setup: generate_version
	$(MAKE) -C lib/gnu-efi
endif

$(SECTIONS): setup
	$(MAKE) -f src/$@/$@.mk SRCDIR=src/$@ BUILDDIR=build/$@ BINDIR=bin/$@

$(MODULES): $(SECTIONS)
	$(MAKE) -f $@ SRCDIR=$(basename $(dir $@)) BUILDDIR=$(patsubst src/%,build/%,$(basename $(dir $@))) BINDIR=bin/modules MODULE=$(basename $(notdir $@))

#argon2: $(MODULES)
#	@if [ ! -d "lib/argon2" ]; then \
#		git clone https://github.com/KaiNorberg/phc-winner-argon2-patchworkos.git lib/argon2; \
#		mkdir -p include/argon2; \
#		cp lib/argon2/include/argon2.h include/argon2/; \
#	fi
#	$(MAKE) -C lib/argon2 -f Makefile.patchwork

$(PACKAGES): $(MODULES) argon2
	$(MAKE) -f $@ SRCDIR=$(basename $(dir $@)) BUILDDIR=$(patsubst src/%,build/%,$(basename $(dir $@))) BINDIR=bin/pkg PKG=$(basename $(notdir $@))

$(PROGRAMS): $(PACKAGES)
	$(MAKE) -f $@ SRCDIR=$(basename $(dir $@)) BUILDDIR=$(patsubst src/%,build/%,$(basename $(dir $@))) BINDIR=bin/programs PROGRAM=$(basename $(notdir $@))

deploy: $(PROGRAMS)
	dd if=/dev/zero of=$(IMAGE) bs=2M count=64
	mformat -F -C -t 256 -h 16 -s 63 -v "PATCHWORKOS" -i $(IMAGE) ::
	mlabel -i $(IMAGE) ::PatchworkOS
	$(foreach dir,$(ROOT_DIRS),mmd -i $(IMAGE) ::/$(dir);)
	mcopy -i $(IMAGE) -s root/* ::
	mcopy -i $(IMAGE) -s LICENSE ::/usr/license
	mcopy -i $(IMAGE) -s bin/boot/bootx64.efi ::/efi/boot
	mcopy -i $(IMAGE) -s bin/kernel/kernel ::/kernel
	mcopy -i $(IMAGE) -s bin/modules/* ::/kernel/modules/$(VERSION_STRING)
	mcopy -i $(IMAGE) -s bin/libstd/libstd.a ::/sys/lib
	mcopy -i $(IMAGE) -s bin/libpatchwork/libpatchwork.a ::/sys/lib
	mcopy -i $(IMAGE) -s include/* ::/sys/include
#$(foreach prog,$(BIN_PROGRAMS),mcopy -i $(IMAGE) -s bin/programs/$(prog) ::/bin;)
	$(foreach prog,$(SBIN_PROGRAMS),mcopy -i $(IMAGE) -s bin/programs/$(prog) ::/sbin;)
	$(foreach prog,$(SYS_BIN_PROGRAMS),mcopy -i $(IMAGE) -s bin/programs/$(prog) ::/sys/bin;)
	$(foreach pkg,$(PKG_PACKAGES),mmd -i $(IMAGE) ::/pkg/$(pkg)/bin && mcopy -i $(IMAGE) -s bin/pkg/$(pkg) ::/pkg/$(pkg)/bin;)
#$(foreach prog,$(USR_BIN_PROGRAMS),mcopy -i $(IMAGE) -s bin/programs/$(prog) ::/usr/bin;)

# This will only work if you have setup a grub loopback entry as described in the README.md file.
grub_loopback:
	cp $(IMAGE) /data/PatchworkOS.img

compile_commands: clean
	bear -- $(MAKE) all

format:
	find src/ include/ meta/doxy tools/ -iname '*.h' -o -iname '*.c' -o -iname '*.dox' | xargs clang-format -style=file -i

clean:
	rm -rf build
	rm -rf bin
	rm -rf $(VERSION_HEADER)

clean_programs:
	rm -rf build/programs
	rm -rf bin/programs

nuke: clean
	$(MAKE) -C lib/gnu-efi clean
	rm -rf lib/doomgeneric-patchworkos
	rm -rf lib/lua-5.4.7
	rm -rf lib/acpica
	rm -rf lib/acpica_tests
	rm -rf lib/argon2
	rm -rf include/argon2
	rm -rf meta/docs

doxygen:
	if [ ! -d "meta/docs/doxygen-awesome-css" ]; then \
	    git clone https://github.com/jothepro/doxygen-awesome-css.git meta/docs/doxygen-awesome-css; \
		cd meta/docs/doxygen-awesome-css; \
		git checkout v2.3.4; \
		cd ../../../..; \
	fi
	@GIT_VERSION_STRING=$$(git describe --tags --always --dirty --long 2>/dev/null || echo "unknown"); \
    sed -i "s/^PROJECT_NUMBER.*/PROJECT_NUMBER           = \"$$GIT_VERSION_STRING\"/" meta/doxy/Doxyfile
	doxygen meta/doxy/Doxyfile
	mkdir -p meta/docs/html/meta/screenshots
	cp meta/screenshots/* meta/docs/html/meta/screenshots/

QEMU_MEMORY ?= 1G
QEMU_CPUS ?= $(shell nproc 2>/dev/null || echo 8)
QEMU_MACHINE ?= q35
QEMU_ARGS ?=

QEMU_FLAGS = \
	-M $(QEMU_MACHINE) \
	-display sdl \
	-serial stdio \
	-drive format=raw,file=$(IMAGE) \
	-m $(QEMU_MEMORY) \
	-smp $(QEMU_CPUS) \
	-cpu qemu64 \
	-drive if=pflash,format=raw,unit=0,file=lib/OVMFbin/OVMF_CODE-pure-efi.fd,readonly=on \
	-drive if=pflash,format=raw,unit=1,file=lib/OVMFbin/OVMF_VARS-pure-efi.fd

ifeq ($(DEBUG),1)

else
	QEMU_FLAGS += -no-shutdown -no-reboot
endif

ifeq ($(QEMU_EXIT_ON_PANIC),1)
	QEMU_FLAGS += -device isa-debug-exit
endif

ifeq ($(GDB),1)
	QEMU_FLAGS += -s -S
endif

run:
	qemu-system-x86_64 $(QEMU_FLAGS) $(QEMU_ARGS)

# We use ACPICA's runtime test suite to validate our ACPI implementation.
#
# The tests seem to be structured like this:
# - ACPICA runtime tests are all found in tests/aslts/src/runtime/collections in the ACPICA repository.
# - Each collection includes sub-collections and have a "FULL" sub-collection that includes all tests in the collection.
# - We want each sub-collection on their own, each sub-collection has a MAIN.asl file that contain a MAIN method, these are the files we want to compile.
#
# At least this is my interpretation of the ACPICA test structure. Could be wrong but it seems to work.
#
# So what we do is clone the ACPICA repository if we don't have it already, then we find all MAIN.asl files that are not in a "FULL" sub-collection,
# compile them to AML using iasl and convert the AML to a C header file using xxd, finally we create a single file that includes all tests.
#
# We can then in `aml_tests.c` include this generated file and run all tests in a loop.
#
# Note that we probably dont want all collections. For now we only use the "functional" collection and we will add more later.
#
# Please check the ACPICA repo for more information.
#
# And yeah the make code is a mess.

ACPICA_COLLECTIONS = functional

clone_acpica_and_compile_tests:
	@if [ ! -d "lib/acpica" ]; then \
		git clone https://github.com/KaiNorberg/acpica.git -b fix_runtime_implicit_return_test lib/acpica; \
	fi
	@if [ ! -d "lib/acpica_tests" ]; then \
		mkdir -p lib/acpica_tests; \
		cd lib/acpica && \
		# We disable exception checking as we instead just allow any behaviour that would cause an exception. \
		# ACPICAs tests call the CH04 method to check for exceptions, so we just use a little search and replace \
		# to add a "Return (0x00)" at the start of the CH04 method to disable it. \
		sed -i '/Method (CH04, 7, NotSerialized)/{N;s/Method (CH04, 7, NotSerialized)\n    {/&\n        Return (0x00) \/* Disabled by clone_acpica_and_compile_tests *\//;}' tests/aslts/src/runtime/cntl/ehandle.asl && \
        # Now we compile all tests. \
		COLLECTIONS="$(ACPICA_COLLECTIONS)"; \
		for COLLECTION in $$COLLECTIONS; do \
			ALL_FILES=$$(find tests/aslts/src/runtime/collections/$$COLLECTION -type f -name 'MAIN.asl' ! -path '*FULL*' 2>/dev/null); \
			for FILE in $$ALL_FILES; do \
				DIR=$$(dirname $$FILE); \
				OUT_DIR=../acpica_tests/$${DIR#tests/aslts/src/runtime/collections/}; \
				mkdir -p $$OUT_DIR; \
				echo "Compiling asl test $$FILE to $$OUT_DIR/test.aml and $$OUT_DIR/test.h"; \
				iasl -va -oa -f -p $$OUT_DIR/test.aml $$FILE > /dev/null; \
				xxd -i $$OUT_DIR/test.aml | sed 's/^unsigned/static unsigned/' > $$OUT_DIR/test.h; \
			done; \
		done; \
	fi
	@if [ ! -f "lib/acpica_tests/all_tests.h" ]; then \
        cd lib/acpica_tests; \
		# Generate a file that includes all test.h files and contains an array that lists them all. \
		touch all_tests.h; \
		echo "#pragma once" > all_tests.h; \
		echo "" >> all_tests.h; \
        echo "/**" >> all_tests.h; \
        echo " * @file all_tests.h" >> all_tests.h; \
        echo " * @brief Generated by Makefile from ACPICA test suite." >> all_tests.h; \
        echo " */" >> all_tests.h; \
        echo "" >> all_tests.h; \
        find . -type f -name 'test.h' | while read line; do \
            echo "#include \"$${line#lib/}\"" >> all_tests.h; \
        done; \
        echo "" >> all_tests.h; \
        echo "#define ACPICA_TEST_COUNT $$(find ../acpica_tests -type f -name 'test.h' | wc -l)" >> all_tests.h; \
        echo "" >> all_tests.h; \
        echo "typedef struct" >> all_tests.h; \
        echo "{" >> all_tests.h; \
        echo "    const char* name;" >> all_tests.h; \
        echo "    unsigned int length;" >> all_tests.h; \
        echo "    unsigned char* aml;" >> all_tests.h; \
        echo "} acpica_test_t;" >> all_tests.h; \
        echo "" >> all_tests.h; \
        echo "static acpica_test_t acpicaTests[ACPICA_TEST_COUNT] = {" >> all_tests.h; \
        find . -type f -name 'test.aml' | while read line; do \
            # Construct the name that xxd uses for example ___acpica_tests_service_condbranches_test_aml for acpica_tests/service/condbranches/test.aml \
            XXD_NAME=___acpica_tests_$$(echo $${line#./} | tr '/' '_' | tr '-' '_' | tr '.' '_'); \
            echo "    { \"$${line#./}\", sizeof($${XXD_NAME}), $${XXD_NAME} }," >> all_tests.h; \
        done; \
        echo "};" >> all_tests.h; \
        cd ../..; \
	fi
