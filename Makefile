IMAGE = bin/PatchworkOS.img

VERSION_HEADER = include/kernel/version.h
VERSION_STRING := $(shell git describe --tags --always --dirty --long 2>/dev/null || echo "unknown")

ROOT_DIRS = acpi base base/bin base/lib base/include base/data box cfg dev efi efi/boot kernel kernel/modules kernel/modules/$(VERSION_STRING) net proc sbin sys tmp

BOOT_TARGET = bin/boot/.built
KERNEL_TARGET = bin/kernel/.built
LIBSTD_TARGET = bin/libstd/.built
LIBPATCHWORK_TARGET = bin/libpatchwork/.built

MODULES_MK = $(shell find src/modules/ -name "*.mk" 2>/dev/null)
MODULES_NAMES = $(basename $(notdir $(MODULES_MK)))
MODULES_TARGETS = $(patsubst %,bin/modules/.%.built,$(MODULES_NAMES))

BOXES_MK = $(shell find src/boxes/ -name "*.mk" 2>/dev/null)
BOXES_NAMES = $(basename $(notdir $(BOXES_MK)))
BOXES_TARGETS = $(patsubst %,bin/boxes/.%.built,$(BOXES_NAMES))

PROGRAMS_MK = $(shell find src/programs/ -name "*.mk" 2>/dev/null)
PROGRAMS_NAMES = $(basename $(notdir $(PROGRAMS_MK)))
PROGRAMS_TARGETS = $(patsubst %,bin/programs/.%.built,$(PROGRAMS_NAMES))

# Programs to be installed in /sbin
SBIN_PROGRAMS = init boxd
# Programs to be installed in /base/bin
BASE_BIN_PROGRAMS = $(filter-out $(SBIN_PROGRAMS),$(PROGRAMS_NAMES))
# Programs to be installed in /box/<box_name>/bin
BOX_PROGRAMS = $(BOXES_NAMES)

.PHONY: all setup deploy run clean generate_version compile_commands format doxygen clean_programs nuke grub_loopback argon2

all: $(IMAGE)

$(IMAGE): bin/.deployed
	@echo "SUCCESS $(IMAGE)"

bin/.deployed: $(BOOT_TARGET) $(KERNEL_TARGET) $(LIBSTD_TARGET) $(LIBPATCHWORK_TARGET) $(MODULES_TARGETS) $(BOXES_TARGETS) $(PROGRAMS_TARGETS) | bin
	@echo "DEPLOY  $(IMAGE)"
	@dd if=/dev/zero of=$(IMAGE) bs=2M count=64 2>/dev/null
	@mformat -F -C -t 256 -h 16 -s 63 -v "PATCHWORKOS" -i $(IMAGE) ::
	@mlabel -i $(IMAGE) ::PatchworkOS
	@$(foreach dir,$(ROOT_DIRS),mmd -i $(IMAGE) ::/$(dir) 2>/dev/null;)
	@mcopy -i $(IMAGE) -s root/* :: 2>/dev/null || true
	@mcopy -i $(IMAGE) -s LICENSE ::/base/license 2>/dev/null || true
	@mcopy -i $(IMAGE) -s bin/boot/bootx64.efi ::/efi/boot 2>/dev/null || true
	@mcopy -i $(IMAGE) -s bin/kernel/kernel ::/kernel 2>/dev/null || true
	@if [ -d bin/modules ] && [ -n "$$(ls -A bin/modules 2>/dev/null)" ]; then \
		mcopy -i $(IMAGE) -s bin/modules/* ::/kernel/modules/$(VERSION_STRING) 2>/dev/null || true; \
	fi
	@mcopy -i $(IMAGE) -s bin/libstd/libstd.a ::/base/lib 2>/dev/null || true
	@mcopy -i $(IMAGE) -s bin/libpatchwork/libpatchwork.a ::/base/lib 2>/dev/null || true
	@if [ -d include ]; then \
		mcopy -i $(IMAGE) -s include/* ::/base/include 2>/dev/null || true; \
	fi
	@$(foreach prog,$(SBIN_PROGRAMS),\
		if [ -f bin/programs/$(prog) ]; then \
			mcopy -i $(IMAGE) -s bin/programs/$(prog) ::/sbin 2>/dev/null || true; \
		fi;)
	@$(foreach prog,$(BASE_BIN_PROGRAMS),\
		if [ -f bin/programs/$(prog) ]; then \
			mcopy -i $(IMAGE) -s bin/programs/$(prog) ::/base/bin 2>/dev/null || true; \
		fi;)
	@$(foreach prog,$(BOX_PROGRAMS),\
		if [ -f bin/boxes/$(prog) ]; then \
			mmd -i $(IMAGE) ::/box/$(prog)/bin 2>/dev/null || true; \
			mcopy -i $(IMAGE) -s bin/boxes/$(prog) ::/box/$(prog)/bin 2>/dev/null || true; \
		fi;)
	@touch $@

ifeq ($(TESTING),1)
setup: lib/gnu-efi/.built lib/acpica_tests/.built $(VERSION_HEADER)
else
setup: lib/gnu-efi/.built $(VERSION_HEADER)
endif

$(VERSION_HEADER): .FORCE | include/kernel
	@printf "#pragma once\n\n" > $@.tmp
	@printf "/**\n * @file version.h\n * @brief Generated by Makefile from Git information.\n */\n\n" >> $@.tmp
	@printf "#define OS_NAME \"PatchworkOS\"\n" >> $@.tmp
	@printf "#define OS_VERSION \"$(VERSION_STRING)\"\n\n" >> $@.tmp
	@if ! cmp -s $@ $@.tmp 2>/dev/null; then \
		mv $@.tmp $@; \
		echo "GEN     $(VERSION_HEADER)"; \
	else \
		rm $@.tmp; \
	fi

include/kernel:
	@mkdir -p $@

lib/gnu-efi/.built: | lib/gnu-efi
	@echo "BUILD   gnu-efi"
	@$(MAKE) -C lib/gnu-efi >/dev/null 2>&1
	@touch $@

$(BOOT_TARGET): setup | bin/boot
	@echo "BUILD   boot"
	@$(MAKE) -s --no-print-directory -f src/boot/boot.mk SRCDIR=src/boot BUILDDIR=build/boot BINDIR=bin/boot all
	@touch $@

$(KERNEL_TARGET): setup | bin/kernel
	@echo "BUILD   kernel"
	@$(MAKE) -s --no-print-directory -f src/kernel/kernel.mk SRCDIR=src/kernel BUILDDIR=build/kernel BINDIR=bin/kernel all
	@touch $@

$(LIBSTD_TARGET): setup | bin/libstd
	@echo "BUILD   libstd"
	@$(MAKE) -s --no-print-directory -f src/libstd/libstd.mk SRCDIR=src/libstd BUILDDIR=build/libstd BINDIR=bin/libstd all
	@touch $@

$(LIBPATCHWORK_TARGET): setup | bin/libpatchwork
	@echo "BUILD   libpatchwork"
	@$(MAKE) -s --no-print-directory -f src/libpatchwork/libpatchwork.mk SRCDIR=src/libpatchwork BUILDDIR=build/libpatchwork BINDIR=bin/libpatchwork all
	@touch $@

lib/argon2/.built: $(MODULES_TARGETS)
	@if [ ! -d "lib/argon2" ]; then \
		echo "CLONE   argon2"; \
		git clone https://github.com/KaiNorberg/phc-winner-argon2-patchworkos.git lib/argon2 >/dev/null 2>&1; \
		mkdir -p include/argon2; \
		cp lib/argon2/include/argon2.h include/argon2/; \
	fi
	@echo "BUILD   argon2"
	@$(MAKE) -C lib/argon2 -f Makefile.patchwork >/dev/null 2>&1
	@touch $@

define MODULE_RULE
bin/modules/.$(1).built: $(filter %/$(1).mk,$(MODULES_MK)) $(BOOT_TARGET) $(KERNEL_TARGET) $(LIBSTD_TARGET) $(LIBPATCHWORK_TARGET) | bin/modules
	@echo "BUILD   module $(1)"
	@$$(MAKE) -s --no-print-directory -f $$(filter %/$(1).mk,$$(MODULES_MK)) SRCDIR=$$(dir $$(filter %/$(1).mk,$$(MODULES_MK))) BUILDDIR=build/modules/$(1) BINDIR=bin/modules MODULE=$(1) all
	@touch $$@
endef

$(foreach mod,$(MODULES_NAMES),$(eval $(call MODULE_RULE,$(mod))))

define BOX_RULE
bin/boxes/.$(1).built: $(filter %/$(1).mk,$(BOXES_MK)) $(MODULES_TARGETS) lib/argon2/.built | bin/boxes
	@echo "BUILD   box $(1)"
	@$$(MAKE) -s --no-print-directory -f $$(filter %/$(1).mk,$$(BOXES_MK)) SRCDIR=$$(dir $$(filter %/$(1).mk,$$(BOXES_MK))) BUILDDIR=build/boxes/$(1) BINDIR=bin/boxes BOX=$(1) all
	@touch $$@
endef

$(foreach box,$(BOXES_NAMES),$(eval $(call BOX_RULE,$(box))))

define PROGRAM_RULE
bin/programs/.$(1).built: $(filter %/$(1).mk,$(PROGRAMS_MK)) $(BOXES_TARGETS) | bin/programs
	@echo "BUILD   program $(1)"
	@$$(MAKE) -s --no-print-directory -f $$(filter %/$(1).mk,$$(PROGRAMS_MK)) SRCDIR=$$(dir $$(filter %/$(1).mk,$$(PROGRAMS_MK))) BUILDDIR=build/programs/$(1) BINDIR=bin/programs PROGRAM=$(1) all
	@touch $$@
endef

$(foreach prog,$(PROGRAMS_NAMES),$(eval $(call PROGRAM_RULE,$(prog))))

bin bin/boot bin/kernel bin/libstd bin/libpatchwork bin/modules bin/boxes bin/programs:
	@mkdir -p $@

lib/acpica_tests/.built: | lib
	@if [ ! -d "lib/acpica" ]; then \
		echo "CLONE   acpica"; \
		git clone https://github.com/KaiNorberg/acpica.git -b fix_runtime_implicit_return_test lib/acpica >/dev/null 2>&1; \
	fi
	@if [ ! -d "lib/acpica_tests" ]; then \
		echo "BUILD   acpica_tests"; \
		mkdir -p lib/acpica_tests; \
		cd lib/acpica && \
		sed -i '/Method (CH04, 7, NotSerialized)/{N;s/Method (CH04, 7, NotSerialized)\n    {/&\n        Return (0x00) \/* Disabled *\//;}' tests/aslts/src/runtime/cntl/ehandle.asl 2>/dev/null || true && \
		COLLECTIONS="functional"; \
		for COLLECTION in $$COLLECTIONS; do \
			ALL_FILES=$$(find tests/aslts/src/runtime/collections/$$COLLECTION -type f -name 'MAIN.asl' ! -path '*FULL*' 2>/dev/null); \
			for FILE in $$ALL_FILES; do \
				DIR=$$(dirname $$FILE); \
				OUT_DIR=../acpica_tests/$${DIR#tests/aslts/src/runtime/collections/}; \
				mkdir -p $$OUT_DIR; \
				iasl -va -oa -f -p $$OUT_DIR/test.aml $$FILE >/dev/null 2>&1 || true; \
				xxd -i $$OUT_DIR/test.aml 2>/dev/null | sed 's/^unsigned/static unsigned/' > $$OUT_DIR/test.h 2>/dev/null || true; \
			done; \
		done; \
	fi
	@if [ ! -f "lib/acpica_tests/all_tests.h" ]; then \
		cd lib/acpica_tests && \
		echo "#pragma once" > all_tests.h && \
		echo "" >> all_tests.h && \
		echo "/**" >> all_tests.h && \
		echo " * @file all_tests.h" >> all_tests.h && \
		echo " * @brief Generated by Makefile from ACPICA test suite." >> all_tests.h && \
		echo " */" >> all_tests.h && \
		echo "" >> all_tests.h && \
		find . -type f -name 'test.h' 2>/dev/null | while read line; do \
			echo "#include \"$${line#lib/}\"" >> all_tests.h; \
		done && \
		echo "" >> all_tests.h && \
		echo "#define ACPICA_TEST_COUNT $$(find . -type f -name 'test.h' 2>/dev/null | wc -l)" >> all_tests.h && \
		echo "" >> all_tests.h && \
		echo "typedef struct" >> all_tests.h && \
		echo "{" >> all_tests.h && \
		echo "    const char* name;" >> all_tests.h && \
		echo "    unsigned int length;" >> all_tests.h && \
		echo "    unsigned char* aml;" >> all_tests.h && \
		echo "} acpica_test_t;" >> all_tests.h && \
		echo "" >> all_tests.h && \
		echo "static acpica_test_t acpicaTests[ACPICA_TEST_COUNT] = {" >> all_tests.h && \
		find . -type f -name 'test.aml' 2>/dev/null | while read line; do \
			XXD_NAME=___acpica_tests_$$(echo $${line#./} | tr '/' '_' | tr '-' '_' | tr '.' '_'); \
			echo "    { \"$${line#./}\", sizeof($${XXD_NAME}), $${XXD_NAME} }," >> all_tests.h; \
		done && \
		echo "};" >> all_tests.h; \
	fi
	@touch $@

lib:
	@mkdir -p $@

grub_loopback: $(IMAGE)
	@echo "COPY    $(IMAGE) to /data"
	@cp $(IMAGE) /data/PatchworkOS.img

compile_commands: clean
	@echo "GEN     compile_commands.json"
	@bear -- $(MAKE) all

format:
	@echo "FORMAT  source code"
	@find src/ include/ meta/doxy tools/ -iname '*.h' -o -iname '*.c' -o -iname '*.dox' 2>/dev/null | xargs clang-format -style=file -i

doxygen:
	@if [ ! -d "meta/docs/doxygen-awesome-css" ]; then \
		echo "CLONE   doxygen-awesome-css"; \
		git clone https://github.com/jothepro/doxygen-awesome-css.git meta/docs/doxygen-awesome-css >/dev/null 2>&1; \
		cd meta/docs/doxygen-awesome-css && git checkout v2.3.4 >/dev/null 2>&1; \
	fi
	@echo "GEN     documentation"
	@GIT_VERSION_STRING=$$(git describe --tags --always --dirty --long 2>/dev/null || echo "unknown"); \
	sed -i "s/^PROJECT_NUMBER.*/PROJECT_NUMBER = \"$$GIT_VERSION_STRING\"/" meta/doxy/Doxyfile
	@doxygen meta/doxy/Doxyfile
	@mkdir -p meta/docs/html/meta/screenshots
	@cp meta/screenshots/* meta/docs/html/meta/screenshots/ 2>/dev/null || true

clean:
	@echo "CLEAN   build bin"
	@rm -rf build bin $(VERSION_HEADER)

clean_programs:
	@echo "CLEAN   programs"
	@rm -rf build/programs bin/programs
	@rm -f $(PROGRAMS_TARGETS)

nuke: clean
	@echo "NUKE    all"
	@$(MAKE) -C lib/gnu-efi clean 2>/dev/null || true
	@rm -rf lib/doomgeneric-patchworkos lib/lua-5.4.7 lib/acpica lib/acpica_tests lib/argon2 include/argon2 meta/docs
	@rm -rf lib/gnu-efi/.built lib/argon2/.built lib/acpica_tests/.built

QEMU_MEMORY ?= 1G
QEMU_CPUS ?= $(shell nproc 2>/dev/null || echo 8)
QEMU_MACHINE ?= q35
QEMU_ARGS ?=

QEMU_FLAGS = \
	-M $(QEMU_MACHINE) \
	-display sdl \
	-serial stdio \
	-drive format=raw,file=$(IMAGE) \
	-m $(QEMU_MEMORY) \
	-smp $(QEMU_CPUS) \
	-cpu qemu64 \
	-drive if=pflash,format=raw,unit=0,file=lib/OVMFbin/OVMF_CODE-pure-efi.fd,readonly=on \
	-drive if=pflash,format=raw,unit=1,file=lib/OVMFbin/OVMF_VARS-pure-efi.fd

ifeq ($(DEBUG),1)
else
QEMU_FLAGS += -no-shutdown -no-reboot
endif

ifeq ($(QEMU_EXIT_ON_PANIC),1)
QEMU_FLAGS += -device isa-debug-exit
endif

ifeq ($(GDB),1)
QEMU_FLAGS += -s -S
endif

run: $(IMAGE)
	@echo "RUN     qemu"
	@qemu-system-x86_64 $(QEMU_FLAGS) $(QEMU_ARGS)

.FORCE:

.SECONDARY:

.SILENT: